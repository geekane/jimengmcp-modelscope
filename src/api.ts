import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import * as crypto from 'crypto';
import path from 'path';
import fs from 'fs';
// @ts-ignore
import crc32 from 'crc32';


// æ¨¡å‹æ˜ å°„
const MODEL_MAP: Record<string, string> = {
  'jimeng-4.0': 'high_aes_general_v40',
  'jimeng-3.0': 'high_aes_general_v30l:general_v3.0_18b',
  'jimeng-2.1': 'high_aes_general_v21_L:general_v2.1_L',
  'jimeng-2.0-pro': 'high_aes_general_v20_L:general_v2.0_L',
  'jimeng-2.0': 'high_aes_general_v20:general_v2.0',
  'jimeng-1.4': 'high_aes_general_v14:general_v1.4',
  'jimeng-xl-pro': 'text2img_xl_sft',
};

// å·¥å…·å‡½æ•°
const generateUuid = (): string => {
  return uuidv4();
};

const jsonEncode = (obj: any): string => {
  return JSON.stringify(obj);
};

const urlEncode = (str: string): string => {
  return encodeURI(str);
};

const unixTimestamp = () => {
  return parseInt(`${Date.now() / 1000}`);
}


// å¸¸é‡å®šä¹‰
const DEFAULT_MODEL = 'jimeng-3.0';
const DEFAULT_BLEND_MODEL = 'jimeng-3.0';
const DRAFT_VERSION = '3.0.2';
const DEFAULT_ASSISTANT_ID = '513695'; // ä»åŸå§‹ä»“åº“ä¸­æå–
const WEB_ID = Math.random() * 999999999999999999 + 7000000000000000000;
const USER_ID = generateUuid().replace(/-/g, '');

// æ¥å£å®šä¹‰
interface LogoInfo {
  add_logo?: boolean; // æ˜¯å¦æ·»åŠ æ°´å° é»˜è®¤ä¸æ·»åŠ 
  position?: number; // 0-å³ä¸‹è§’ 1-å·¦ä¸‹è§’ 2-å·¦ä¸Šè§’ 3-å³ä¸Šè§’
  language?: number; // 0-ä¸­æ–‡ï¼ˆAIç”Ÿæˆï¼‰1-è‹±æ–‡ï¼ˆGenerated by AIï¼‰
  opacity?: number; // 0-1 default: 0.3
  logo_text_content?: string; // æ°´å°æ–‡å­—å†…å®¹
}

interface ImageGenerationParams {
  filePath?: string; // å›¾ç‰‡è·¯å¾„
  model?: string; // æ¨¡å‹åç§°ï¼Œé»˜è®¤ä½¿ç”¨ DEFAULT_MODEL
  prompt: string; // æç¤ºè¯
  width?: number; // å›¾åƒå®½åº¦ï¼Œé»˜è®¤1024
  height?: number; // å›¾åƒé«˜åº¦ï¼Œé»˜è®¤1024
  sample_strength?: number; // ç²¾ç»†åº¦ï¼Œé»˜è®¤0.5
  negative_prompt?: string; // åå‘æç¤ºè¯ï¼Œé»˜è®¤ç©º
  refresh_token?: string; // åˆ·æ–°ä»¤ç‰Œï¼Œå¿…éœ€
  req_key?: string; // è‡ªå®šä¹‰å‚æ•°ï¼Œå…¼å®¹æ—§æ¥å£
}

export function generateCookie(refreshToken: string) {
  return [
    `_tea_web_id=${WEB_ID}`,
    `is_staff_user=false`,
    `store-region=cn-gd`,
    `store-region-src=uid`,
    `sid_guard=${refreshToken}%7C${unixTimestamp()}%7C5184000%7CMon%2C+03-Feb-2025+08%3A17%3A09+GMT`,
    `uid_tt=${USER_ID}`,
    `uid_tt_ss=${USER_ID}`,
    `sid_tt=${refreshToken}`,
    `sessionid=${refreshToken}`,
    `sessionid_ss=${refreshToken}`,
    `sid_tt=${refreshToken}`
  ].join("; ");
}

// å³æ¢¦APIå®¢æˆ·ç«¯ç±»
class JimengApiClient {
  private refreshToken: string;
  private getUploadImageProofUrl = 'https://imagex.bytedanceapi.com/'

  constructor() {
    this.refreshToken = process.env.JIMENG_API_TOKEN || '';
    if (!this.refreshToken) {
      throw new Error('JIMENG_API_TOKEN ç¯å¢ƒå˜é‡æœªè®¾ç½®');
    }
  }

  /**
   * è·å–æ¨¡å‹æ˜ å°„
   * @param model æ¨¡å‹åç§°
   * @returns æ˜ å°„åçš„æ¨¡å‹åç§°
   */
  private getModel(model: string): string {
    return MODEL_MAP[model] || MODEL_MAP[DEFAULT_MODEL];
  }

  /**
   * å‘é€è¯·æ±‚åˆ°å³æ¢¦API
   * @param method è¯·æ±‚æ–¹æ³•
   * @param path è¯·æ±‚è·¯å¾„
   * @param data è¯·æ±‚æ•°æ®
   * @param params è¯·æ±‚å‚æ•°
   * @param headers è¯·æ±‚å¤´
   * @returns å“åº”ç»“æœ
   */
  private async request(
    method: string,
    path: string,
    data: any = {},
    params: any = {},
    headers: any = {}
  ): Promise<any> {
    const baseUrl = 'https://jimeng.jianying.com';
    const url = path.includes('https://') ? path : `${baseUrl}${path}`;
    const FAKE_HEADERS = {
      Accept: "application/json, text/plain, */*",
      "Accept-Encoding": "gzip, deflate, br, zstd",
      "Accept-language": "zh-CN,zh;q=0.9",
      "Cache-control": "no-cache",
      "Last-event-id": "undefined",
      Appid: DEFAULT_ASSISTANT_ID,
      Appvr: "5.8.0",
      Origin: "https://jimeng.jianying.com",
      Pragma: "no-cache",
      Priority: "u=1, i",
      Referer: "https://jimeng.jianying.com",
      Pf: "7",
      "Sec-Ch-Ua":
        '"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"',
      "Sec-Ch-Ua-Mobile": "?0",
      "Sec-Ch-Ua-Platform": '"Windows"',
      "Sec-Fetch-Dest": "empty",
      "Sec-Fetch-Mode": "cors",
      "Sec-Fetch-Site": "same-origin",
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
    };
    const requestHeaders = {
      ...FAKE_HEADERS,
      'Cookie': generateCookie(this.refreshToken),
      ...headers
    };

    // --- å¼€å§‹æ—¥å¿—æ‰“å° ---

    console.log("================ âœ¨ å³æ¢¦APIè¯·æ±‚å¼€å§‹ âœ¨ ================");
    console.log(`[è¯·æ±‚æ–¹æ³•]: ${method.toUpperCase()}`);
    console.log(`[è¯·æ±‚ URL]: ${url}`);
    
    // ä¸ºäº†æ—¥å¿—æ¸…æ™°ï¼Œåªæ‰“å°æœ‰å†…å®¹çš„å‚æ•°
    if (Object.keys(params).length > 0) {
      console.log("[è¯·æ±‚å‚æ•° (Query Params)]:", params);
    }
    if (Object.keys(data).length > 0) {
        // å¯¹äºå¤æ‚çš„è¯·æ±‚ä½“ï¼Œä½¿ç”¨JSON.stringify(data, null, 2)å¯ä»¥æ ¼å¼åŒ–è¾“å‡ºï¼Œæ›´æ˜“è¯»
        console.log("[è¯·æ±‚ä½“ (Body)]:", data); 
    }
    // è¯·æ±‚å¤´å†…å®¹è¾ƒå¤šï¼Œå¯ä»¥æ ¹æ®éœ€è¦å†³å®šæ˜¯å¦æ‰“å°
    // console.log("[è¯·æ±‚å¤´ (Headers)]:", requestHeaders);

    try {
      const response = await axios({
        method: method.toLowerCase(),
        url,
        data: method.toUpperCase() !== 'GET' ? data : undefined,
        params: method.toUpperCase() === 'GET' ? { ...data, ...params } : params,
        headers: requestHeaders
      });

      // æ‰“å°æˆåŠŸçš„å“åº”
      console.log("\nâœ… [è¯·æ±‚æˆåŠŸ]");
      console.log("[å“åº”æ•°æ®]:", response.data);
      console.log("================ ğŸš€ å³æ¢¦APIè¯·æ±‚ç»“æŸ ğŸš€ ================\n");

      return response.data;
    } catch (error) {
      // æ‰“å°å¤±è´¥çš„å“åº”
      console.error("\nâŒ [è¯·æ±‚å¤±è´¥]");
      if (axios.isAxiosError(error) && error.response) {
        console.error(`[é”™è¯¯çŠ¶æ€ç ]: ${error.response.status}`);
        console.error("[é”™è¯¯å“åº”ä½“]:", error.response.data);
        console.log("================ ğŸ’€ å³æ¢¦APIè¯·æ±‚ç»“æŸ ğŸ’€ ================\n");
        throw new Error(`å³æ¢¦APIè¯·æ±‚é”™è¯¯: ${JSON.stringify(error.response.data)}`);
      } else {
        console.error("[æœªçŸ¥é”™è¯¯è¯¦æƒ…]:", error);
        console.log("================ ğŸ’€ å³æ¢¦APIè¯·æ±‚ç»“æŸ ğŸ’€ ================\n");
        throw new Error(`å³æ¢¦APIè¯·æ±‚å¤±è´¥: ${error}`);
      }
    }
  }

  /**
   * è·å–ç§¯åˆ†ä¿¡æ¯
   * @returns ç§¯åˆ†ä¿¡æ¯
   */
  public async getCredit(): Promise<Record<string, number>> {
    const result = await this.request(
      'POST',
      '/commerce/v1/benefits/user_credit',
      {},
      {},
      { 'Referer': 'https://jimeng.jianying.com/ai-tool/image/generate' }
    );

    const credit = result.credit || {};
    const giftCredit = credit.gift_credit || 0;
    const purchaseCredit = credit.purchase_credit || 0;
    const vipCredit = credit.vip_credit || 0;

    return {
      giftCredit,
      purchaseCredit,
      vipCredit,
      totalCredit: giftCredit + purchaseCredit + vipCredit
    };
  }

  /**
   * é¢†å–ç§¯åˆ†
   */
  public async receiveCredit(): Promise<void> {
    await this.request(
      'POST',
      '/commerce/v1/benefits/credit_receive',
      { 'time_zone': 'Asia/Shanghai' },
      {},
      { 'Referer': 'https://jimeng.jianying.com/ai-tool/image/generate' }
    );
  }

  /**
   * å³æ¢¦AIå›¾åƒç”Ÿæˆ (æœ€ç»ˆçš„ã€æœ€å¥å£®çš„ç‰ˆæœ¬)
   * @param params å›¾åƒç”Ÿæˆå‚æ•°
   * @returns åŒ…å«æ—¥å¿—ã€çŠ¶æ€å’Œç»“æœçš„JSONå­—ç¬¦ä¸²
   */
  public async generateImage(params: ImageGenerationParams): Promise<string[]> {
    const logBuffer: string[] = [];
    try {
      // --- (æ–¹æ³•å‰åŠéƒ¨åˆ†çš„å‚æ•°å‡†å¤‡ä»£ç å®Œå…¨ä¸å˜) ---
      if (!params.prompt || typeof params.prompt !== 'string') { throw new Error('promptå¿…é¡»æ˜¯éç©ºå­—ç¬¦ä¸²'); }
      const hasFilePath = params?.filePath;
      let uploadID = null;
      if (params?.filePath) {
        logBuffer.push("[ä»»åŠ¡å‡†å¤‡] æ£€æµ‹åˆ°æ–‡ä»¶è·¯å¾„ï¼Œå¼€å§‹ä¸Šä¼ ...");
        uploadID = await this.uploadCoverFile(params.filePath);
        logBuffer.push(`[ä»»åŠ¡å‡†å¤‡] æ–‡ä»¶ä¸Šä¼ æˆåŠŸ, UploadID: ${uploadID}`);
      }
      const modelName = hasFilePath ? DEFAULT_BLEND_MODEL : params.model || DEFAULT_MODEL;
      const actualModel = this.getModel(modelName);
      logBuffer.push(`[ä»»åŠ¡å‡†å¤‡] ä½¿ç”¨æ¨¡å‹: ${modelName} -> ${actualModel}`);
      logBuffer.push("[ä»»åŠ¡å‡†å¤‡] æ­£åœ¨æ£€æŸ¥ç”¨æˆ·ç§¯åˆ†...");
      const creditInfo = await this.getCredit();
      logBuffer.push(`[ä»»åŠ¡å‡†å¤‡] ç§¯åˆ†ä¿¡æ¯: ${JSON.stringify(creditInfo)}`);
      if (creditInfo.totalCredit <= 0) {
        logBuffer.push("[ä»»åŠ¡å‡†å¤‡] ç§¯åˆ†ä¸º0ï¼Œå°è¯•é¢†å–æ¯æ—¥ç§¯åˆ†...");
        await this.receiveCredit();
        logBuffer.push("[ä»»åŠ¡å‡†å¤‡] æ¯æ—¥ç§¯åˆ†é¢†å–æˆåŠŸã€‚");
      }
      const componentId = generateUuid();
      const rqParams = { "babi_param": urlEncode(jsonEncode({ "scenario": "image_video_generation", "feature_key": hasFilePath ? "to_image_referenceimage_generate" : "aigc_to_image", "feature_entrance": "to_image", "feature_entrance_detail": hasFilePath ? "to_image-referenceimage-byte_edit" : `to_image-${actualModel}`, })), "aid": parseInt(DEFAULT_ASSISTANT_ID), "device_platform": "web", "region": "CN", "web_id": WEB_ID };
      let abilities: Record<string, any> = {};
      if (hasFilePath) { /* ... blend abilities ... */ } 
      else { abilities = { "generate": { "type": "", "id": generateUuid(), "core_param": { "type": "", "id": generateUuid(), "model": actualModel, "prompt": params.prompt, "negative_prompt": params.negative_prompt || "", "seed": Math.floor(Math.random() * 100000000) + 2500000000, "sample_strength": params.sample_strength || 0.5, "image_ratio": 1, "large_image_info": { "type": "", "id": generateUuid(), "height": params.height || 1024, "width": params.width || 1024, "resolution_type": '1k' } }, "history_option": { "type": "", "id": generateUuid(), } } }; }
      const rqData = { "extend": { "root_model": actualModel, "template_id": "", }, "submit_id": generateUuid(), "metrics_extra": hasFilePath ? undefined : jsonEncode({ "templateId": "", "generateCount": 1, "promptSource": "custom", "templateSource": "", "lastRequestId": "", "originRequestId": "", }), "draft_content": jsonEncode({ "type": "draft", "id": generateUuid(), "min_version": DRAFT_VERSION, "is_from_tsn": true, "version": "3.2.2", "main_component_id": componentId, "component_list": [{ "type": "image_base_component", "id": componentId, "min_version": DRAFT_VERSION, "metadata": { "type": "", "id": generateUuid(), "created_platform": 3, "created_platform_version": "", "created_time_in_ms": Date.now(), "created_did": "" }, "generate_type": hasFilePath ? "blend" : "generate", "aigc_mode": "workbench", "abilities": { "type": "", "id": generateUuid(), ...abilities } }] }), };
      logBuffer.push("[ä»»åŠ¡å‡†å¤‡] è¯·æ±‚å‚æ•°æ„é€ å®Œæ¯•ã€‚");
      
      logBuffer.push("\n[æ­¥éª¤ 1] æ­£åœ¨å‘æœåŠ¡å™¨æäº¤ç”Ÿæˆä»»åŠ¡...");
      const result = await this.request('POST', '/mweb/v1/aigc_draft/generate', rqData, rqParams);
      const historyId = result?.data?.aigc_data?.history_record_id;
      if (!historyId) { throw new Error(`æœªèƒ½ä»åˆå§‹å“åº”ä¸­è·å– History IDã€‚å“åº”: ${JSON.stringify(result)}`); }
      logBuffer.push(`[æ­¥éª¤ 1] æˆåŠŸè·å– History ID: ${historyId}`);
      logBuffer.push("\n[æ­¥éª¤ 2] å¼€å§‹è½®è¯¢è·å–ç”Ÿæˆç»“æœ...");

      let status = 20;
      let failCode = null;
      let itemList: any[] = [];
      let pollCount = 1;

      // ======================= æœ€ç»ˆçš„ã€æœ€å¥å£®çš„ä¿®æ”¹ =======================
      // å½“çŠ¶æ€æ˜¯ "å¤„ç†ä¸­"(20) æˆ– ä»»ä½•4å¼€å¤´çš„çŠ¶æ€ç (æ’é˜Ÿ/å‡†å¤‡ä¸­) æ—¶ï¼Œéƒ½ç»§ç»­è½®è¯¢
      while (status === 20 || (status >= 40 && status < 50)) {
      // ================================================================
        if (pollCount > 60) { throw new Error("è½®è¯¢è¶…æ—¶ï¼šç­‰å¾…æ—¶é—´è¿‡é•¿ï¼Œä»»åŠ¡å¯èƒ½å·²åœ¨åç«¯å¤±è´¥ã€‚"); }
        await new Promise(resolve => setTimeout(resolve, 1000));
        const pollResult = await this.request(
          'POST',
          '/mweb/v1/get_history_by_ids',
          { "history_ids": [historyId], "image_info": { "width": 2048, "height": 2048, "format": "webp", "image_scene_list": [ { "scene": "smart_crop", "width": 360, "height": 360, "uniq_key": "smart_crop-w:360-h:360", "format": "webp" }, { "scene": "smart_crop", "width": 480, "height": 480, "uniq_key": "smart_crop-w:480-h:480", "format": "webp" }, { "scene": "smart_crop", "width": 720, "height": 720, "uniq_key": "smart_crop-w:720-h:720", "format": "webp" }, { "scene": "smart_crop", "width": 720, "height": 480, "uniq_key": "smart_crop-w:720-h:480", "format": "webp" }, { "scene": "smart_crop", "width": 360, "height": 240, "uniq_key": "smart_crop-w:360-h:240", "format": "webp" }, { "scene": "smart_crop", "width": 240, "height": 320, "uniq_key": "smart_crop-w:240-h:320", "format": "webp" }, { "scene": "smart_crop", "width": 480, "height": 640, "uniq_key": "smart_crop-w:480-h:640", "format": "webp" }, { "scene": "normal", "width": 2400, "height": 2400, "uniq_key": "2400", "format": "webp" }, { "scene": "normal", "width": 1080, "height": 1080, "uniq_key": "1080", "format": "webp" }, { "scene": "normal", "width": 720, "height": 720, "uniq_key": "720", "format": "webp" }, { "scene": "normal", "width": 480, "height": 480, "uniq_key": "480", "format": "webp" }, { "scene": "normal", "width": 360, "height": 360, "uniq_key": "360", "format": "webp" } ] }, "http_common_info": { "aid": parseInt(DEFAULT_ASSISTANT_ID) } }
        );
        const record = pollResult?.data?.[historyId];
        logBuffer.push(`\n[è½®è¯¢ #${pollCount}]`);
        logBuffer.push(`æœåŠ¡å™¨è¿”å›çš„ 'record' å¯¹è±¡: ${JSON.stringify(record, null, 2)}`);
        pollCount++;
        if (!record) { throw new Error(`è½®è¯¢å¤±è´¥ï¼šè®°å½•ä¸å­˜åœ¨ã€‚æœåŠ¡å™¨å“åº”: ${JSON.stringify(pollResult?.data)}`); }

        status = record.status;
        failCode = record.fail_code;
        itemList = record.item_list || [];
        
        logBuffer.push(`æå–çŠ¶æ€: status=${status}, fail_code=${failCode}`);

        if (status === 30) {
          if (failCode === '2038') { throw new Error('å†…å®¹è¢«è¿‡æ»¤ (fail_code: 2038)'); }
          throw new Error(`å›¾åƒç”Ÿæˆå¤±è´¥ (status: 30, fail_code: ${failCode})`);
        }
      }

      logBuffer.push("\n[æ­¥éª¤ 3] è½®è¯¢ç»“æŸ, æœ€ç»ˆçš„ itemList:", JSON.stringify(itemList, null, 2));
      logBuffer.push("\n[æ­¥éª¤ 4] å¼€å§‹æå–å›¾ç‰‡é“¾æ¥...");
      const imageUrls = itemList.map(item => {
        const imageUrl = item?.image?.large_images?.[0]?.image_url || item?.common_attr?.cover_url;
        logBuffer.push(`ä» item ä¸­æ‰¾åˆ°çš„ URL æ˜¯ -> ${imageUrl}`);
        return imageUrl;
      }).filter(Boolean);

      if (imageUrls.length === 0) {
        if (status !== 50) {
          throw new Error(`ä»»åŠ¡ä»¥æœªçŸ¥çš„æœ€ç»ˆçŠ¶æ€ ${status} ç»“æŸï¼Œå¹¶ä¸”æœªèƒ½æå–åˆ°å›¾ç‰‡URLã€‚`);
        }
        logBuffer.push("è­¦å‘Š: ä»»åŠ¡çœ‹ä¼¼æˆåŠŸ(status:50)ï¼Œä½†æœªèƒ½ä»æœ€ç»ˆçš„ itemList ä¸­æå–åˆ°ä»»ä½•å›¾ç‰‡URLã€‚");
      }
      
      // @ts-ignore
      return JSON.stringify({ success: true, logs: logBuffer, images: imageUrls });

    } catch (error: any) {
      logBuffer.push(`\nâŒ [å‘ç”Ÿä¸¥é‡é”™è¯¯]: ${error.message}`);
      // @ts-ignore
      return JSON.stringify({ success: false, logs: logBuffer, error: error.message });
    }
  }
  
  /**
  * è·å–ä¸Šä¼ å‡­è¯æ‰€éœ€Akå’ŒTk
  */
  private async getUploadAuth(): Promise<any> {
    return new Promise(async (resolve, reject) => {
      try {
        const authRes = await this.request(
          'POST',
          '/mweb/v1/get_upload_token?aid=513695&da_version=3.2.2&aigc_features=app_lip_sync',
          {
            scene: 2
          },
          {},
        );
        if (
          !authRes.data
        ) {
          reject(authRes.errmsg ?? 'è·å–ä¸Šä¼ å‡­è¯å¤±è´¥,è´¦å·å¯èƒ½å·²æ‰çº¿!');
          return;
        }
        resolve(authRes.data);
      } catch (err) {
        console.error('è·å–ä¸Šä¼ å‡­è¯å¤±è´¥:', err);
        reject(err);
      }
    });
  }

public async getFileContent(filePath: string): Promise<Buffer> {
  try {
    // æ–°å¢ï¼šè¯†åˆ« Base64 æ•°æ®
    if (filePath.startsWith('data:')) {
      const base64Data = filePath.split(',')[1]; // ç§»é™¤ "data:image/...;base64," å‰ç¼€
      return Buffer.from(base64Data, 'base64');
    }
    // åŸæœ‰é€»è¾‘ï¼šå¤„ç† URL æˆ–æœ¬åœ°è·¯å¾„
    if (filePath.includes('https://') || filePath.includes('http://')) {
      const res = await axios.get(filePath, { responseType: 'arraybuffer' });
      return Buffer.from(res.data);
    } else {
      const absolutePath = path.resolve(filePath);
      return await fs.promises.readFile(absolutePath);
    }
  } catch (error) {
    console.error('Failed to read file:', error);
    throw new Error(`è¯»å–æ–‡ä»¶å¤±è´¥: ${filePath}`); // ä¿®å¤ï¼šæ˜¾ç¤ºå®é™…è·¯å¾„
  }
}
  private generateRandomString(length: number): string {
    let result = '';
    const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  }

  /**
  * ç”Ÿæˆè¯·æ±‚æ‰€éœ€Header
  */
  private addHeaders(
    amzDate: string,
    sessionToken: string,
    requestBody: any,
  ): any {
    const headers = {
      'X-Amz-Date': amzDate,
      'X-Amz-Security-Token': sessionToken,
    };
    if (Object.keys(requestBody).length > 0) {
      // @ts-ignore
      headers['X-Amz-Content-Sha256'] = crypto
        .createHash('sha256')
        .update(JSON.stringify(requestBody))
        .digest('hex');
    }
    return headers;
  }

  /**
   * ç”Ÿæˆè¯·æ±‚æ‰€éœ€Header
   */
  private async generateAuthorizationAndHeader(
    accessKeyID: string,
    secretAccessKey: string,
    sessionToken: string,
    region: string,
    service: string,
    requestMethod: string,
    requestParams: any,
    requestBody: any = {},
  ): Promise<any> {
    return new Promise((resolve) => {
      // è·å–å½“å‰ISOæ—¶é—´
      const now = new Date();
      const amzDate = now.toISOString().replace(/[:\-]|\.\d{3}/g, '').slice(0, 15) + 'Z';

      // ç”Ÿæˆè¯·æ±‚çš„Header
      const requestHeaders: Record<string, string> = this.addHeaders(
        amzDate,
        sessionToken,
        requestBody,
      )

      if (Object.keys(requestBody).length > 0) {
        // @ts-ignore
        requestHeaders['X-Amz-Content-Sha256'] = crypto
          .createHash('sha256')
          .update(JSON.stringify(requestBody))
          .digest('hex')
      }
      // ç”Ÿæˆè¯·æ±‚çš„Authorization
      const authorizationParams = [
        'AWS4-HMAC-SHA256 Credential=' + accessKeyID + '/' +
        this.credentialString(amzDate, region, service),
        'SignedHeaders=' + this.signedHeaders(requestHeaders),
        'Signature=' + this.signature(
          secretAccessKey,
          amzDate,
          region,
          service,
          requestMethod,
          requestParams,
          requestHeaders,
          requestBody,
        ),
      ];
      const authorization = authorizationParams.join(', ');

      // è¿”å›Headers
      const headers: any = {};
      for (const key in requestHeaders) {
        headers[key] = requestHeaders[key];
      }
      headers['Authorization'] = authorization;
      resolve(headers);
    });
  }

  /**
   * è·å–credentialString
   */
  private credentialString(
    amzDate: string,
    region: string,
    service: string,
  ): string {
    const credentialArr = [
      amzDate.substring(0, 8),
      region,
      service,
      'aws4_request',
    ];
    return credentialArr.join('/');
  }

  /**
   * ç”Ÿæˆhttpè¯·æ±‚å‚æ•°å­—ç¬¦ä¸²
   */
  private httpBuildQuery(params: any): string {
    const searchParams = new URLSearchParams();
    for (const key in params) {
      if (params?.hasOwnProperty(key)) {
        searchParams.append(key, params[key]);
      }
    }
    return searchParams.toString();
  }

  private signedHeaders(requestHeaders: any): string {
    const headers: string[] = [];
    Object.keys(requestHeaders).forEach(function (r) {
      r = r.toLowerCase();
      headers.push(r);
    });
    return headers.sort().join(';');
  }


  /**
   * ç”ŸæˆcanonicalString
   */
  private canonicalString(
    requestMethod: string,
    requestParams: any,
    requestHeaders: any,
    requestBody: any,
  ): string {
    let canonicalHeaders: string[] = [];
    const headerKeys = Object.keys(requestHeaders).sort();
    for (let i = 0; i < headerKeys.length; i++) {
      canonicalHeaders.push(
        headerKeys[i].toLowerCase() + ':' + requestHeaders[headerKeys[i]],
      );
    }
    // @ts-ignore
    canonicalHeaders = canonicalHeaders.join('\n') + '\n';
    let body = '';
    if (Object.keys(requestBody).length > 0) {
      body = JSON.stringify(requestBody);
    }

    const canonicalStringArr = [
      requestMethod.toUpperCase(),
      '/',
      this.httpBuildQuery(requestParams),
      canonicalHeaders,
      this.signedHeaders(requestHeaders),
      crypto.createHash('sha256').update(body).digest('hex'),
    ];
    return canonicalStringArr.join('\n');
  }

  private signature(
    secretAccessKey: string,
    amzDate: string,
    region: string,
    service: string,
    requestMethod: string,
    requestParams: any,
    requestHeaders: any,
    requestBody: any,
  ): string {
    // ç”ŸæˆsigningKey
    const amzDay = amzDate.substring(0, 8);
    const kDate = crypto
      .createHmac('sha256', 'AWS4' + secretAccessKey)
      .update(amzDay)
      .digest();
    const kRegion = crypto.createHmac('sha256', kDate).update(region).digest();
    const kService = crypto
      .createHmac('sha256', kRegion)
      .update(service)
      .digest();
    const signingKey = crypto
      .createHmac('sha256', kService)
      .update('aws4_request')
      .digest();

    // ç”ŸæˆStringToSign
    const stringToSignArr = [
      'AWS4-HMAC-SHA256',
      amzDate,
      this.credentialString(amzDate, region, service),
      crypto
        .createHash('sha256')
        .update(
          this.canonicalString(
            requestMethod,
            requestParams,
            requestHeaders,
            requestBody,
          ),
        )
        .digest('hex'),
    ];
    const stringToSign = stringToSignArr.join('\n');
    return crypto
      .createHmac('sha256', signingKey)
      .update(stringToSign)
      .digest('hex');
  }

  /**
   * ä¸Šä¼ æ–‡ä»¶åˆ°è¿œç¨‹æœåŠ¡å™¨
   * @param url ä¸Šä¼ åœ°å€
   * @param fileContent æ–‡ä»¶å†…å®¹
   * @param headers è¯·æ±‚å¤´
   * @param method HTTP æ–¹æ³•
   * @param proxy
   */
  private async uploadFile(
    url: string,
    fileContent: Buffer,
    headers: any,
    method: string = 'PUT',
  ): Promise<any> {
    return new Promise(async (resolve, reject) => {
      const res = await this.request(
        'POST',
        url,
        fileContent,
        {},
        headers
      );
      resolve(res);
    });
  }

  /**
   * ä¸Šä¼ æ–‡ä»¶
   */
  private async uploadCoverFile(
    filePath: string,
  ): Promise<string> {
    return new Promise(async (resolve, reject) => {
      try {
        // è·å–ä¸Šä¼ ä»¤ç‰Œæ‰€éœ€Akå’ŒTk
        const uploadAuth = await this.getUploadAuth();

        // è·å–å›¾ç‰‡æ•°æ®
        const imageRes = await this.getFileContent(filePath);
        // è·å–å›¾ç‰‡Crc32æ ‡è¯†
        const imageCrc32 = crc32(imageRes).toString(16);
        // è·å–å›¾ç‰‡ä¸Šä¼ å‡­è¯ç­¾åæ‰€éœ€å‚æ•°
        const getUploadImageProofRequestParams = {
          Action: 'ApplyImageUpload',
          FileSize: imageRes.length,
          ServiceId: 'tb4s082cfz',
          Version: '2018-08-01',
          s: this.generateRandomString(11),
        };

        // è·å–å›¾ç‰‡ä¸Šä¼ è¯·æ±‚å¤´
        const requestHeadersInfo = await this.generateAuthorizationAndHeader(
          uploadAuth.access_key_id,
          uploadAuth.secret_access_key,
          uploadAuth.session_token,
          'cn-north-1',
          'imagex',
          'GET',
          getUploadImageProofRequestParams,
        );


        // è·å–å›¾ç‰‡ä¸Šä¼ å‡­è¯
        const uploadImgRes = await this.request(
          'GET',
          this.getUploadImageProofUrl + '?' +
          this.httpBuildQuery(getUploadImageProofRequestParams),
          {},
          {},
          requestHeadersInfo
        );

        if (uploadImgRes?.['Response  ']?.hasOwnProperty('Error')) {
          reject(uploadImgRes['Response ']['Error']['Message']);
          return;
        }

        const UploadAddress = uploadImgRes.Result.UploadAddress;
        // ç”¨å‡­è¯æ‹¼æ¥ä¸Šä¼ å›¾ç‰‡æ¥å£
        const uploadImgUrl = `https://${UploadAddress.UploadHosts[0]}/upload/v1/${UploadAddress.StoreInfos[0].StoreUri}`;

        // ä¸Šä¼ å›¾ç‰‡
        const imageUploadRes = await this.uploadFile(
          uploadImgUrl,
          imageRes,
          {
            Authorization: UploadAddress.StoreInfos[0].Auth,
            'Content-Crc32': imageCrc32,
            'Content-Type': 'application/octet-stream',
            // 'X-Storage-U': '3674996648187204',
          },
          'POST',
        );


        if (imageUploadRes.code !== 2000) {
          reject(imageUploadRes.message);
          return;
        }

        const commitImgParams = {
          Action: 'CommitImageUpload',
          FileSize: imageRes.length,
          ServiceId: 'tb4s082cfz',
          Version: '2018-08-01',
          // user_id: userUid,
        };

        const commitImgContent = {
          SessionKey: UploadAddress.SessionKey,
        };

        const commitImgHead = await this.generateAuthorizationAndHeader(
          uploadAuth.access_key_id,
          uploadAuth.secret_access_key,
          uploadAuth.session_token,
          'cn-north-1',
          'imagex',
          'POST',
          commitImgParams,
          commitImgContent,
        );

        // æäº¤å›¾ç‰‡ä¸Šä¼ 
        const commitImg = await this.request(
          'POST',
          this.getUploadImageProofUrl +
          '?' +
          this.httpBuildQuery(commitImgParams),
          commitImgContent,
          {},
          {
            ...commitImgHead,
            'Content-Type': 'application/json',
          }
        );

        if (commitImg['Response ']?.hasOwnProperty('Error')) {
          reject(commitImg['Response  ']['Error']['Message']);
          return;
        }


        resolve(commitImg.Result.Results[0].Uri);
      } catch (err: any) {
        console.error('ä¸Šä¼ æ–‡ä»¶å¤±è´¥:', err);
        const errorMessage = err?.message || err || 'æœªçŸ¥';
        reject('ä¸Šä¼ å¤±è´¥,å¤±è´¥åŸå› :' + errorMessage);
      }
    });
  }

}

// åˆ›å»ºAPIå®¢æˆ·ç«¯å®ä¾‹
const apiClient = new JimengApiClient();


// å¯¼å‡ºå‡½æ•°ï¼Œä¿æŒå¯¹å¤–æ¥å£ä¸å˜
export const generateImage = (params: ImageGenerationParams): Promise<string[]> => {
  return apiClient.generateImage(params);
};

// å¯¼å‡ºæ¥å£å®šä¹‰ï¼Œä»¥ä¾¿å…¶ä»–æ¨¡å—ä½¿ç”¨
export type { ImageGenerationParams, LogoInfo };
